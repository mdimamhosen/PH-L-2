-- Active: 1743661936863@@127.0.0.1@5432@ph
/*
    @Procedural Approach:
    1. Language Support: Supports procedural languages like PL/pgSQL, PL/Perl, PL/Python, etc.
    2. Complex Logic: Allows for complex logic using control structures like loops, conditionals, and exception handling.
    3. Variable Support: Supports variable declarations and manipulation within the procedural code.    
    4. Stored Procedures/Functions: Provides the ability to create stored procedures or functions, which can encapsulate complex logic and be reused across different applications.
    5. Transaction Control: Can manage transactions explicitly, allowing for better control over commit and rollback operations.
    6. Performance: May offer better performance for complex operations due to the ability to optimize execution plans and reduce network round trips.
    7. Error Handling: Provides robust error handling mechanisms, allowing developers to catch and handle exceptions gracefully.


     @Non-Procedural Approach:
    1. Declarative Queries: Focuses on writing declarative SQL queries to retrieve, insert, update, or delete data from the database.
    2. Simplicity: Emphasizes simplicity by expressing operations in terms of what data is needed.
    3. SQL Functions: Supports SQL functions, which are single SQL statements that return a value or set of values.
    4. Performance: Can sometimes offer better performance for simple operations due to the optimized query execution plans generated by the database engine.
    5. Readability: SQL queries are often more readable and easier to understand for those familiar with SQL syntax.
    6. Portability: Non-procedural SQL code can be more portable across different database systems, as it relies on standard SQL syntax rather than procedural constructs.
    7. Limited Control Structures: Lacks the advanced control structures and error handling capabilities found in procedural languages, making it less suitable for complex logic.
    8. No Variable Declarations: Does not support variable declarations or manipulation within the SQL code, limiting its ability to handle complex scenarios.


*/

SELECT * FROM orders;


SELECT * FROM orders;

CREATE FUNCTION get_order_count()
RETURNS INT
AS
$$
SELECT COUNT(*) FROM orders;
$$
LANGUAGE SQL;

SELECT get_order_count();


SELECT get_order_count();


CREATE FUNCTION get_details_by_id(p_order_id INT)
RETURNS TABLE(order_id INT, customer_id VARCHAR, order_date DATE) 
AS
$$
SELECT order_id, customer_id, order_date
FROM orders WHERE order_id = p_order_id;    
$$
LANGUAGE SQL;

SELECT * FROM get_details_by_id(1);
SELECT * FROM get_details_by_id(2);


-- ! PROCEDURE EXAMPLE:

CREATE OR REPLACE PROCEDURE remove_order_by_id(p_order_id INT)
LANGUAGE plpgsql
AS
$$
BEGIN -- BEGIN block starts here
    -- Declare a variable to hold the order count
    DECLARE order_count INT;
    -- Select the count of orders with the given order_id into the variable
    DELETE FROM orders WHERE order_id = p_order_id;
    -- Check if the order was deleted successfully
    SELECT COUNT(*) INTO order_count FROM orders WHERE order_id = p_order_id;
    -- If the order count is still greater than 0, raise an exception
    IF order_count > 0 THEN
        RAISE EXCEPTION 'Order with ID % could not be deleted', p_order_id;
    ELSE
        RAISE NOTICE 'Order with ID % has been deleted successfully', p_order_id;
    END IF; -- END IF block ends here
END; -- END block ends here
$$

CALL remove_order_by_id(1);
CALL remove_order_by_id(2);